/* 
@author : Anwar Saipul Rohmi
artstyle generated by patorjk.com
*/
import java.util.Arrays;
import java.util.Scanner;

public class Chess
{
    static String playerOne;//white
    static String playerTwo;//black
    static char activePlayer='w';
    static final String author="Anwar Saipul Rohmi";
    static final char[]piece={'K'/*king*/,'Q'/*queen*/,'R'/*rock*/,'B'/*bishop*/,'H'/*knight*/,'P'/*pawn*/,'k','q','r','b','h','p'};
    static final char[]whitePawn={piece[0],piece[1],piece[2],piece[3],piece[4],piece[5]};
    static final char[]blackPawn={piece[6],piece[7],piece[8],piece[9],piece[10],piece[11]};
    static final char[]alphabetPos={'A','B','C','D','E','F','G','H'};
    static final int[]numberPos={1,2,3,4,5,6,7,8};
    static final char[]boardSymbol={'+','-'};
    static final char[][]referenceBoard=
    {
        {piece[8],piece[10],piece[9],piece[7],piece[6],piece[9],piece[10],piece[8]},
        {piece[11],piece[11],piece[11],piece[11],piece[11],piece[11],piece[11],piece[11]},
        {boardSymbol[0],boardSymbol[1],boardSymbol[0],boardSymbol[1],boardSymbol[0],boardSymbol[1],boardSymbol[0],boardSymbol[1]},
        {boardSymbol[1],boardSymbol[0],boardSymbol[1],boardSymbol[0],boardSymbol[1],boardSymbol[0],boardSymbol[1],boardSymbol[0]},
        {boardSymbol[0],boardSymbol[1],boardSymbol[0],boardSymbol[1],boardSymbol[0],boardSymbol[1],boardSymbol[0],boardSymbol[1]},
        {boardSymbol[1],boardSymbol[0],boardSymbol[1],boardSymbol[0],boardSymbol[1],boardSymbol[0],boardSymbol[1],boardSymbol[0]},
        {piece[5],piece[5],piece[5],piece[5],piece[5],piece[5],piece[5],piece[5]},
        {piece[2],piece[4],piece[3],piece[1],piece[0],piece[3],piece[4],piece[2]}
    };
    static final String titleArt=
                "              ,,                                \r\n" + //
                "  .g8\"\"\"bgd `7MM                                \r\n" + //
                ".dP'     `M   MM                                \r\n" + //
                "dM'       `   MMpMMMb.  .gP\"Ya  ,pP\"Ybd ,pP\"Ybd \r\n" + //
                "MM            MM    MM ,M'   Yb 8I   `\" 8I   `\" \r\n" + //
                "MM.           MM    MM 8M\"\"\"\"\"\" `YMMMa. `YMMMa. \r\n" + //
                "`Mb.     ,'   MM    MM YM.    , L.   I8 L.   I8 \r\n" + //
                "  `\"bmmmd'  .JMML  JMML.`Mbmmd' M9mmmP' M9mmmP' ";
    static char[][]board=referenceBoard;
    static boolean debug=true;
    static boolean allowFreeMovement=false;
    static Scanner scanner=new Scanner(System.in);
    public static void main(String[]arguments)
    {
        mainMenu();
    }
    static void mainMenu()
    {
        displayTitle();
        displayMenu();
        int inputMenu=scanner.nextInt();
        switch(inputMenu)
        {
            case 1:
                playerOne=getPlayer(1);
                playerTwo=getPlayer(2);
                program();
                break;
            default:
                System.out.println("Please insert a valid number!");
                mainMenu();
                break;
        }
    }
    static void displayTitle()
    {
        System.out.println(titleArt);
        System.out.println("===============================================");
        System.out.println("By : "+author);
    }
    static void displayMenu()
    {
        System.out.println("1) Play");
    }
    static void program()
    {
        displayBoard();
        program();
    }
    static String getPlayer(int x)
    {
        Scanner scanner1=new Scanner(System.in);
        Scanner scanner2=new Scanner(System.in);
        String player=new String();
        if(x==1)
        {
            System.out.println("Insert name of player one(white)");
            player=scanner1.nextLine();
        }
        else if(x==2)
        {
            System.out.println("Insert name of player two(black)");
            player=scanner2.nextLine();
        }
        return player;
    }
    static void displayBoard()
    {
        System.out.print("   ");
        for(int i=0;i<alphabetPos.length;i++)
        {
            System.out.print(alphabetPos[i]+" ");
        }
        System.out.println("   ");
        System.out.print("   ");
        for(int i=0;i<alphabetPos.length;i++)
        {
            System.out.print("==");
        }
        System.out.println("   ");
        for(int i=0;i<numberPos.length;i++)
        {
            System.out.print(numberPos[i]+"| ");
            for(int j=0;j<board[i].length;j++)
            {
                System.out.print(board[i][j]+" ");
            }
            System.out.println("|"+numberPos[i]);
        }
        System.out.print("   ");
        for(int i=0;i<alphabetPos.length;i++)
        {
            System.out.print("==");
        }
        System.out.println("   ");
        System.out.print("   ");
        for(int i=0;i<alphabetPos.length;i++)
        {
            System.out.print(alphabetPos[i]+" ");
        }
        System.out.println("   ");
        getMovement();
    }
    static void getMovement()
    {
        if(activePlayer=='w')
        {
            System.out.println(playerOne+" turn (White)");
        }
        else if(activePlayer=='b')
        {
            System.out.println(playerTwo+" turn (Black)");
        }
        String input=scanner.nextLine().toLowerCase();
        movementCheck(input);
    }
    static void movementCheck(String movement)
    {
        if(movement.length()==4&&Character.isLetter(movement.charAt(0))&&Character.isDigit(movement.charAt(1))&&Character.isLetter(movement.charAt(2))&&Character.isDigit(movement.charAt(3)))
        {
            int[]movementData=getMovementData(movement);
            if(movementData[0]<=7&&movementData[0]>=0&&movementData[1]<=7&&movementData[1]>=0&&movementData[2]<=7&&movementData[2]>=0&&movementData[3]<=7&&movementData[3]>=0)
            {
                int[]startData={movementData[0],movementData[1]};
                int[]targetData={movementData[2],movementData[3]};
                char start=tileChecker(startData);
                char target=tileChecker(targetData);
                char pawn=board[startData[0]][startData[1]];
                if(start==activePlayer&&target!=activePlayer&&startData!=targetData)
                {
                    movementTest(startData,targetData,target,pawn);
                }
                else
                {
                    invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                }
            }
            else
            {
                invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
            }
        }
        else
        {
            invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
        }
    }
    static void movementTest(int[]startData,int[]targetData,char target,char pawn)
    {
        if(pawn==whitePawn[0]|pawn==blackPawn[0])//King
        {
            if((targetData[0]<=startData[0]+1&&targetData[0]>=startData[0]-1)&&(targetData[1]<=startData[1]+1&&targetData[1]>=startData[1]-1))
            {
                move(pawn,startData,targetData);
            }
            else
            {
                invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
            }
        }
        else if(pawn==whitePawn[1]|pawn==blackPawn[1])//queen
        {
            boolean check=false;
            int x=0;
            int y=0;
            if(targetData[0]<startData[0]&&targetData[1]==startData[1])
            {
                for(int i=startData[0];i>targetData[0];i--)
                {
                    int[]checktile={startData[0]-x,startData[1]};
                    char tile=tileChecker(checktile);
                    if(tile!='n'&&checktile[0]!=targetData[0]&&checktile[0]!=startData[0])
                    {
                        invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                        check=true;
                        break;
                    }
                }
                x++;
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]==startData[0]&&targetData[1]>startData[1])
            {
                for(int i=startData[1];i<targetData[1];i++)
                {
                    int[]checktile={startData[0],startData[1]+x};
                    char tile=tileChecker(checktile);
                    if(tile!='n'&&checktile[1]!=targetData[1]&&checktile[1]!=startData[1])
                    {
                        invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                        check=true;
                        break;
                    }
                }
                x++;
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]>startData[0]&&targetData[1]==startData[1])
            {
                for(int i=startData[0];i<targetData[0];i++)
                {
                    int[]checktile={startData[0]+x,startData[1]};
                    char tile=tileChecker(checktile);
                    if(tile!='n'&&checktile[0]!=targetData[0]&&checktile[0]!=startData[0])
                    {
                        invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                        check=true;
                        break;
                    }
                }
                x++;
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]==startData[0]&&targetData[1]<startData[1])
            {
                for(int i=startData[1];i>targetData[0];i--)
                {
                    int[]checktile={startData[0],startData[1]-x};
                    char tile=tileChecker(checktile);
                    if(tile!='n'&&checktile[1]!=targetData[1]&&checktile[1]!=startData[1])
                    {
                        invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                        check=true;
                        break;
                    }
                }
                x++;
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]<startData[0]&&targetData[1]>startData[1]&&Math.abs(targetData[0]-startData[0])==Math.abs(targetData[1]-startData[1]))
            {
                for(int i=startData[0];i>targetData[0];i--)
                {
                    for(int j=startData[1];j<targetData[1];j++)
                    {
                        int[]checktile={startData[0]-y,startData[1]+x};
                        char tile=tileChecker(checktile);
                        if(y==x&&tile!='n'&&checktile[0]!=targetData[0]&&checktile[0]!=startData[0])
                        {
                            check=true;
                            invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                            break;
                        }
                        x++;
                    }
                    y++;
                    x=0;
                }
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]>startData[0]&&targetData[1]>startData[1]&&Math.abs(targetData[0]-startData[0])==Math.abs(targetData[1]-startData[1]))
            {
                for(int i=startData[0];i<targetData[0];i++)
                {
                    for(int j=startData[1];j<targetData[1];j++)
                    {
                        int[]checktile={startData[0]+y,startData[1]+x};
                        char tile=tileChecker(checktile);
                        if(y==x&&tile!='n'&&checktile[0]!=targetData[0]&&checktile[0]!=startData[0])
                        {
                            check=true;
                            invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                            break;
                        }
                        x++;
                    }
                    y++;
                    x=0;
                }
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]>startData[0]&&targetData[1]<startData[1]&&Math.abs(targetData[0]-startData[0])==Math.abs(targetData[1]-startData[1]))
            {
                for(int i=startData[0];i<targetData[0];i++)
                {
                    for(int j=startData[1];j>targetData[1];j--)
                    {
                        int[]checktile={startData[0]+y,startData[1]-x};
                        char tile=tileChecker(checktile);
                        if(y==x&&tile!='n'&&checktile[0]!=targetData[0]&&checktile[0]!=startData[0])
                        {
                            check=true;
                            invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                            break;
                        }
                        x++;
                    }
                    y++;
                    x=0;
                }
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]<startData[0]&&targetData[1]<startData[1]&&Math.abs(targetData[0]-startData[0])==Math.abs(targetData[1]-startData[1]))
            {
                for(int i=startData[0];i>targetData[0];i--)
                {
                    for(int j=startData[1];j>targetData[1];j--)
                    {
                        int[]checktile={startData[0]-y,startData[1]-x};
                        char tile=tileChecker(checktile);
                        if(y==x&&tile!='n'&&checktile[0]!=targetData[0]&&checktile[0]!=startData[0])
                        {
                            check=true;
                            invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                            break;
                        }
                    }
                    y++;
                    x=0;
                }
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else
            {
                invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
            }
        }
        else if(pawn==whitePawn[3]|pawn==blackPawn[3])//bishop
        {
            boolean check=false;
            int x=0;
            int y=0;
            if(targetData[0]<startData[0]&&targetData[1]>startData[1]&&Math.abs(targetData[0]-startData[0])==Math.abs(targetData[1]-startData[1]))
            {
                for(int i=startData[0];i>targetData[0];i--)
                {
                    for(int j=startData[1];j<targetData[1];j++)
                    {
                        int[]checktile={startData[0]-y,startData[1]+x};
                        char tile=tileChecker(checktile);
                        if(y==x&&tile!='n'&&checktile[0]!=targetData[0]&&checktile[0]!=startData[0])
                        {
                            check=true;
                            invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                            break;
                        }
                        x++;
                    }
                    y++;
                    x=0;
                }
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]>startData[0]&&targetData[1]>startData[1]&&Math.abs(targetData[0]-startData[0])==Math.abs(targetData[1]-startData[1]))
            {
                for(int i=startData[0];i<targetData[0];i++)
                {
                    for(int j=startData[1];j<targetData[1];j++)
                    {
                        int[]checktile={startData[0]+y,startData[1]+x};
                        char tile=tileChecker(checktile);
                        if(y==x&&tile!='n'&&checktile[0]!=targetData[0]&&checktile[0]!=startData[0])
                        {
                            check=true;
                            invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                            break;
                        }
                        x++;
                    }
                    y++;
                    x=0;
                }
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]>startData[0]&&targetData[1]<startData[1]&&Math.abs(targetData[0]-startData[0])==Math.abs(targetData[1]-startData[1]))
            {
                for(int i=startData[0];i<targetData[0];i++)
                {
                    for(int j=startData[1];j>targetData[1];j--)
                    {
                        int[]checktile={startData[0]+y,startData[1]-x};
                        char tile=tileChecker(checktile);
                        if(y==x&&tile!='n'&&checktile[0]!=targetData[0]&&checktile[0]!=startData[0])
                        {
                            check=true;
                            invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                            break;
                        }
                        x++;
                    }
                    y++;
                    x=0;
                }
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]<startData[0]&&targetData[1]<startData[1]&&Math.abs(targetData[0]-startData[0])==Math.abs(targetData[1]-startData[1]))
            {
                for(int i=startData[0];i>targetData[0];i--)
                {
                    for(int j=startData[1];j>targetData[1];j--)
                    {
                        int[]checktile={startData[0]-y,startData[1]-x};
                        char tile=tileChecker(checktile);
                        if(y==x&&tile!='n'&&checktile[0]!=targetData[0]&&checktile[0]!=startData[0])
                        {
                            check=true;
                            invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                            break;
                        }
                    }
                    y++;
                    x=0;
                }
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else
            {
                invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
            }
        }
        else if(pawn==whitePawn[4]|pawn==blackPawn[4])//knight
        {
            boolean check=false;
            int[][]knightMovement=
            {
                {startData[0]-2,startData[1]-1},{startData[0]-2,startData[1]+1},
                {startData[0]-1,startData[1]+2},{startData[0]+1,startData[1]+2},
                {startData[0]+2,startData[1]+1},{startData[0]+2,startData[1]-1},
                {startData[0]+1,startData[1]-2},{startData[0]-1,startData[1]-2}
            };
            for(int i=0;i<knightMovement.length;i++)
            {
                if(targetData[0]==knightMovement[i][0]&&targetData[1]==knightMovement[i][1])
                {
                    move(pawn,startData,targetData);
                    check=true;
                    break;
                }
            }
            if(check==false)
            {
                invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
            }
        }
        else if(pawn==whitePawn[2]|pawn==blackPawn[2])//rock
        {
            boolean check=false;
            int x=0;
            if(targetData[0]<startData[0]&&targetData[1]==startData[1])
            {
                for(int i=startData[0];i>targetData[0];i--)
                {
                    int[]checktile={startData[0]-x,startData[1]};
                    char tile=tileChecker(checktile);
                    if(tile!='n'&&checktile[0]!=targetData[0]&&checktile[0]!=startData[0])
                    {
                        invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                        check=true;
                        break;
                    }
                    x++;
                }
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]==startData[0]&&targetData[1]>startData[1])
            {
                for(int i=startData[1];i<targetData[1];i++)
                {
                    int[]checktile={startData[0],startData[1]+x};
                    char tile=tileChecker(checktile);
                    if(tile!='n'&&checktile[1]!=targetData[1]&&checktile[1]!=startData[1])
                    {
                        invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                        check=true;
                        break;
                    }
                    x++;
                }
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]>startData[0]&&targetData[1]==startData[1])
            {
                for(int i=startData[0];i<targetData[0];i++)
                {
                    int[]checktile={startData[0]+x,startData[1]};
                    char tile=tileChecker(checktile);
                    if(tile!='n'&&checktile[0]!=targetData[0]&&checktile[0]!=startData[0])
                    {
                        invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                        check=true;
                        break;
                    }
                }
                x++;
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else if(targetData[0]==startData[0]&&targetData[1]<startData[1])
            {
                for(int i=startData[1];i>targetData[0];i--)
                {
                    int[]checktile={startData[0],startData[1]-x};
                    char tile=tileChecker(checktile);
                    if(tile!='n'&&checktile[1]!=targetData[1]&&checktile[1]!=startData[1])
                    {
                        invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                        check=true;
                        break;
                    }
                }
                x++;
                if(check==false)
                {
                    move(pawn,startData,targetData);
                }
            }
            else
            {
                invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
            }
        }
        else if(pawn==whitePawn[5]|pawn==blackPawn[5]&&allowFreeMovement==false)//pawn
        {
            if(activePlayer=='w')
            {
                if(targetData[1]==startData[1]&&targetData[0]>=startData[0]-2&&targetData[0]<=startData[0]&&target!='b')
                {
                    if(startData[0]<6&&targetData[0]<=startData[0]-2)
                    {
                        invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                    }
                    else
                    {
                        move(pawn,startData,targetData);
                    }
                }
                else if((targetData[1]==startData[1]+1&&targetData[0]==startData[0]-1)|(targetData[1]==startData[1]-1&&targetData[0]==startData[0]-1)&&target=='b')
                {
                    move(pawn,startData,targetData);
                }
                else
                {
                    invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                }
            }
            else if(activePlayer=='b')
            {
                if(targetData[1]==startData[1]&&targetData[0]<=startData[0]+2&&targetData[0]>=startData[0]&&target!='w')
                {
                    if(startData[0]>1&&targetData[0]>=startData[0]+2)
                    {
                        invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                    }
                    else
                    {
                        move(pawn,startData,targetData);
                    }
                }
                else if((targetData[1]==startData[1]+1&&targetData[0]==startData[0]+1)|(targetData[1]==startData[1]-1&&targetData[0]==startData[0]+1)&&target=='b')
                {
                    move(pawn,startData,targetData);
                }
                else
                {
                    invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
                }
            }
        }
        else
        {
            invalidator(Thread.currentThread().getStackTrace()[1].getLineNumber());
        }
    }
    static void move(char pawn,int[]startData,int[]targetData)
    {
        board[targetData[0]][targetData[1]]=pawn;
        fillTile(startData);
    }
    static void fillTile(int[]startData)
    {
        if(startData[0]%2==0)
        {
            if(startData[1]%2==0)
            {
                board[startData[0]][startData[1]]=boardSymbol[0];
            }
            else
            {
                board[startData[0]][startData[1]]=boardSymbol[1];
            }
        }
        else
        {
            if(startData[1]%2==0)
            {
                board[startData[0]][startData[1]]=boardSymbol[1];
            }
            else
            {
                board[startData[0]][startData[1]]=boardSymbol[0];
            }
        }
        eventCheck();
    }
    static void eventCheck()
    {
        boolean checkmate=checkmateCondition();
        if(checkmate)
        {
            result();
        }
        else
        {
            playerSwap();
        }
    }
    static void playerSwap()
    {
        if(activePlayer=='w')
        {
            activePlayer='b';
        }
        else if(activePlayer=='b')
        {
            activePlayer='w';
        }
    }
    static void result()
    {
        if(activePlayer=='w')
        {
            System.out.println("Checkmate, "+playerOne+" win the game!");
        }
        else if(activePlayer=='b')
        {
            System.out.println("Checkmate, "+playerTwo+" win the game!");
        }
        System.exit(0);
    }
    static void invalidator(int x)
    {
        System.out.println("Invalid Movement!");
        if(debug==true)
        {
            System.out.println("Invalid at line "+x);
        }
    }
    static int[]getMovementData(String movement)
    {
        int[]movementData=new int[4];
        movementData[0]=Character.getNumericValue(movement.charAt(1))-1;
        movementData[1]=movement.charAt(0)-'a';
        movementData[2]=Character.getNumericValue(movement.charAt(3))-1;
        movementData[3]=movement.charAt(2)-'a';
        return movementData;
    }
    static char tileChecker(int[]tileData)
    {
        char check='x';
        char currentTile=board[tileData[0]][tileData[1]];
        for(int i=0;i<6;i++)
        {
            if(currentTile==whitePawn[i])
            {
                check='w';
                break;
            }
            else if(currentTile==blackPawn[i])
            {
                check='b';
                break;
            }
        }
        if(check=='x')
        {
            check='n';
        }
        return check;
    }
    static boolean checkmateCondition()
    {
        boolean checkmate=true;
        if(activePlayer=='w')
        {
            for(int i=0;i<board[0].length;i++)
            {
                for(int j=0;j<board[1].length;j++)
                {
                    if(board[i][j]==blackPawn[0])
                    {
                        checkmate=false;
                        break;
                    }
                }
            }
        }
        else if(activePlayer=='b')
        {
            for(int i=0;i<board[0].length;i++)
            {
                for(int j=0;j<board[1].length;j++)
                {
                    if(board[i][j]==whitePawn[0])
                    {
                        checkmate=false;
                        break;
                    }
                }
            }
        }
        return checkmate;
    }
}
